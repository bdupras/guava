/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.common.hash;

import java.io.*;

import javax.annotation.CheckReturnValue;
import javax.annotation.Nullable;

import com.google.common.annotations.Beta;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.hash.CuckooFilterStrategies.CuckooTable;
import com.google.common.primitives.SignedBytes;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.math.DoubleMath.log2;
import static com.google.common.math.LongMath.divide;
import static java.lang.Math.ceil;
import static java.math.RoundingMode.CEILING;
import static java.math.RoundingMode.HALF_DOWN;

/**
 * A Cuckoo filter for instances of {@code T}. A Cuckoo filter offers an approximate containment
 * test with one-sided error: if it claims that an element is contained in it, this might be in
 * error, but if it claims that an element is <i>not</i> contained in it, then this is definitely
 * true.
 *
 * <p>The false positive probability ({@code FPP}) of a cuckoo filter is defined as the probability
 * that {@linkplain #mightContain(Object)} will erroneously return {@code true} for an object that
 * has not actually been put in the {@code CuckooFilter}.
 *
 * <p>Cuckoo filters are serializable. They also support a more compact serial representation via
 * the {@link #writeTo} and {@link #readFrom} methods. Both serialized forms will continue to be
 * supported by future versions of this library. However, serial forms generated by newer versions
 * of the code may not be readable by older versions of the code (e.g., a serialized cuckoo filter
 * generated today may <i>not</i> be readable by a binary that was compiled 6 months ago).
 *
 * ref: Cuckoo Filter: Practically Better Than Bloom
 *      Bin Fan, David G. Andersen, Michael Kaminsky†, Michael D. Mitzenmacher‡
 *      Carnegie Mellon University, †Intel Labs, ‡Harvard University
 *      https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf
 *
 * @param <T> the type of instances that the {@code CuckooFilter} accepts
 * @author Brian Dupras
 * @author Alex Beal
 *
 */
@Beta
public final class CuckooFilter<T> implements Predicate<T>, Serializable {
    interface Strategy extends Serializable {

        <T> boolean put(T object, Funnel<? super T> funnel, long numBuckets, int numEntriesPerBucket, int numBitsPerEntry, CuckooTable table);

        <T> boolean delete(T object, Funnel<? super T> funnel, long numBuckets, int numEntriesPerBucket, int numBitsPerEntry, CuckooTable table);

        <T> boolean mightContain(T object, Funnel<? super T> funnel, long numBuckets, int numEntriesPerBucket, int numBitsPerEntry, CuckooTable table);

        int ordinal();
    }

    private final CuckooTable table;
    private final long numBuckets;
    private final int numEntriesPerBucket;
    private final int numBitsPerEntry;
    private final Funnel<? super T> funnel;
    private final Strategy strategy;

    /**
     * Creates a CuckooFilter.
     */
    private CuckooFilter(
            CuckooTable table,
            long numBuckets,
            int numEntriesPerBucket,
            int numBitsPerEntry,
            Funnel<? super T> funnel,
            Strategy strategy) {
        checkArgument(numBuckets > 0, "numBuckets (%s) must be > 0", numBuckets);
        checkArgument(numEntriesPerBucket > 0, "numEntriesPerBucket (%s) must be > 0", numEntriesPerBucket);
        checkArgument(numBitsPerEntry > 0, "numBitsPerEntry (%s) must be > 0", numBitsPerEntry);
        this.table = checkNotNull(table);
        this.numBuckets = numBuckets;
        this.numEntriesPerBucket = numEntriesPerBucket;
        this.numBitsPerEntry = numBitsPerEntry;
        this.funnel = checkNotNull(funnel);
        this.strategy = checkNotNull(strategy);
    }

    /**
     * Creates a new {@code CuckooFilter} that's a copy of this instance. The new instance is equal to
     * this instance but shares no mutable state.
     */
    @CheckReturnValue
    public CuckooFilter<T> copy() {
        return new CuckooFilter<T>(table.copy(),  numBuckets, numEntriesPerBucket, numBitsPerEntry, funnel, strategy);
    }

    /**
     * Returns {@code true} if the element <i>might</i> have been put in this Cuckoo filter,
     * {@code false} if this is <i>definitely</i> not the case.
     */
    @CheckReturnValue
    public boolean mightContain(T object) {
        return strategy.mightContain(object, funnel, numBuckets, numEntriesPerBucket, numBitsPerEntry, table);
    }

    /**
     * @deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #mightContain}
     * instead.
     */
    @Deprecated
    @CheckReturnValue
    public boolean apply(T input) {
        return mightContain(input);
    }

    /**
     * Puts an element into this {@code CuckooFilter}. Ensures that subsequent invocations of
     * {@link #mightContain(Object)} with the same element will always return {@code true}.
     *
     * @return true if {@code object} has been successfully added to the filter. false if
     * {@code object} was not added to the filter, as would be the case when the filter gets
     * saturated. This may occur even if actualInsertions < expectedInsertions. e.g. If
     * {@code object} has already been added 2*b times to the filter, a subsequent attempt will
     * fail.
     */
    public boolean put(T object) {
        return strategy.put(object, funnel, numBuckets, numEntriesPerBucket, numBitsPerEntry, table);
    }

    /**
     * Deletes {@code object} from this {@code CuckooFilter}. {@code object} must been
     * previously added to the filter. Deleting an {@code object} that hasn't been added to the
     * filter may put the filter in an inconsistent state causing it to return false negative
     * responses from {@code get(t)}.
     *
     * If {@code false} is returned, this is <i>definitely</i> an indication that either this
     * invocation or a previous invocation have called {@code delete(t)} without a matching
     * invocation of {@code put(t)}. This condition is always an error and the this
     * {@code CuckooFilter} can no longer be relied upon to return correct {@code false} responses
     * from {@code get(t)}.
     *
     * @return true if {@code object} was successfully deleted from the filter.
     */
    public boolean delete(T object) {
        return strategy.delete(object, funnel, numBuckets, numEntriesPerBucket, numBitsPerEntry, table);
    }

    /**
     * Returns the probability that {@linkplain #mightContain(Object)} will erroneously return
     * {@code true} for an object that has not actually been put in the {@code CuckooFilter}.
     * <p/>
     * <p>Ideally, this number should be close to the {@code fpp} parameter
     * passed in {@linkplain #create(Funnel, int, double)}, or smaller. If it is
     * significantly higher, it is usually the case that too many elements (more than
     * expected) have been put in the {@code CuckooFilter}, degenerating it.
     */
    @CheckReturnValue
    public double expectedFpp() {
        return ((double)table.entryCount / (2 * numEntriesPerBucket)) / Math.pow(2, numBitsPerEntry);
    }

    /**
     * Determines whether a given cuckoo filter is compatible with this cuckoo filter. For two
     * cuckoo filters to be compatible, they must:
     * <p/>
     * <ul>
     * <li>not be the same instance
     * <li>have the same number of buckets
     * <li>have the same number of entries per bucket
     * <li>have the same number of bits per entry
     * <li>have the same strategy
     * <li>have equal funnels
     * <ul>
     *
     * @param that The cuckoo filter to check for compatibility.
     */
    @CheckReturnValue
    public boolean isCompatible(CuckooFilter<T> that) {
        checkNotNull(that);
        return (this != that)
                && (this.numBuckets == that.numBuckets)
                && (this.numEntriesPerBucket == that.numEntriesPerBucket)
                && (this.numBitsPerEntry == that.numBitsPerEntry)
                && (this.strategy.equals(that.strategy))
                && (this.funnel.equals(that.funnel));
    }

    @Override
    public boolean equals(@Nullable Object object) {
        if (object == this) {
            return true;
        }
        if (object instanceof CuckooFilter) {
            CuckooFilter<?> that = (CuckooFilter<?>) object;
            return this.numBuckets == that.numBuckets
                    && this.numEntriesPerBucket == that.numEntriesPerBucket
                    && this.numBitsPerEntry == that.numBitsPerEntry
                    && this.funnel.equals(that.funnel)
                    && this.table.equals(that.table)
                    && this.strategy.equals(that.strategy);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(numBuckets, numEntriesPerBucket, numBitsPerEntry, funnel, strategy, table);
    }

    /**
     * Creates a {@link CuckooFilter CuckooFilter<T>} with the expected number of
     * insertions and expected false positive probability.
     * <p/>
     * <p>Note that overflowing a {@code CuckooFilter} with significantly more elements
     * than specified, will result in its saturation causing {@code put(t)} to reject new additions.
     * <p/>
     * <p>The constructed {@code CuckooFilter<T>} will be serializable if the provided
     * {@code Funnel<T>} is.
     * <p/>
     * <p>It is recommended that the funnel be implemented as a Java enum. This has the
     * benefit of ensuring proper serialization and deserialization, which is important
     * since {@link #equals} also relies on object identity of funnels.
     *
     * @param funnel             the funnel of T's that the constructed {@code CuckooFilter<T>} will use
     * @param expectedInsertions the number of expected insertions to the constructed
     *                           {@code CuckooFilter<T>}; must be positive
     * @param fpp                the desired false positive probability (must be positive and less than 1.0)
     * @return a {@code CuckooFilter}
     */
    @CheckReturnValue
    public static <T> CuckooFilter<T> create(
            Funnel<? super T> funnel, int expectedInsertions, double fpp) {
        return create(funnel, (long) expectedInsertions, fpp);
    }

    /**
     * Creates a {@link CuckooFilter CuckooFilter<T>} with the expected number of
     * insertions and expected false positive probability.
     * <p/>
     * <p>Note that overflowing a {@code CuckooFilter} with significantly more elements
     * than specified, will result in its saturation causing {@code put(t)} to reject new additions.
     * <p/>
     * <p>The constructed {@code CuckooFilter<T>} will be serializable if the provided
     * {@code Funnel<T>} is.
     * <p/>
     * <p>It is recommended that the funnel be implemented as a Java enum. This has the
     * benefit of ensuring proper serialization and deserialization, which is important
     * since {@link #equals} also relies on object identity of funnels.
     *
     * @param funnel             the funnel of T's that the constructed {@code CuckooFilter<T>} will use
     * @param expectedInsertions the number of expected insertions to the constructed
     *                           {@code CuckooFilter<T>}; must be positive
     * @param fpp                the desired false positive probability (must be positive and less than 1.0)
     * @return a {@code CuckooFilter}
     */
    @CheckReturnValue
    public static <T> CuckooFilter<T> create(
            Funnel<? super T> funnel, long expectedInsertions, double fpp) {
        return create(funnel, expectedInsertions, fpp, CuckooFilterStrategies.MURMUR128_BEALDUPRAS_32);
    }

    @VisibleForTesting
    static <T> CuckooFilter<T> create(Funnel<? super T> funnel, long expectedInsertions, double fpp, Strategy strategy) {
        checkNotNull(funnel);
        checkArgument(expectedInsertions > 0, "Expected insertions (%s) must be > 0", expectedInsertions);
        checkArgument(fpp > 0.0D, "False positive probability (%s) must be > 0.0", fpp);
        checkArgument(fpp < 1.0D, "False positive probability (%s) must be < 1.0", fpp);
        checkNotNull(strategy);

        int numEntriesPerBucket = optimalEntriesPerBucket(fpp);
        long numBuckets = optimalNumberOfBuckets(expectedInsertions, numEntriesPerBucket);
        int numBitsPerEntry = optimalBitsPerEntry(fpp, numEntriesPerBucket);

        try {
            return new CuckooFilter<T>(new CuckooTable(numBuckets, numEntriesPerBucket, numBitsPerEntry), numBuckets, numEntriesPerBucket, numBitsPerEntry, funnel, strategy);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Could not create CuckooFilter of " + numBuckets + " buckets, " + numEntriesPerBucket + " entries per bucket, " + numBitsPerEntry + " bits per entry", e);
        }
    }

    /**
     * Creates a {@link CuckooFilter CuckooFilter<T>} with the expected number of
     * insertions and a default expected false positive probability of 3.2%.
     * <p/>
     * <p>Note that overflowing a {@code CuckooFilter} with significantly more elements
     * than specified, will result in its saturation causing {@code put(t)} to reject new additions.
     * <p/>
     * <p>The constructed {@code CuckooFilter<T>} will be serializable if the provided
     * {@code Funnel<T>} is.
     * <p/>
     * <p>It is recommended that the funnel be implemented as a Java enum. This has the
     * benefit of ensuring proper serialization and deserialization, which is important
     * since {@link #equals} also relies on object identity of funnels.
     *
     * @param funnel             the funnel of T's that the constructed {@code CuckooFilter<T>} will use
     * @param expectedInsertions the number of expected insertions to the constructed
     *                           {@code CuckooFilter<T>}; must be positive
     * @return a {@code CuckooFilter}
     */
    @CheckReturnValue
    public static <T> CuckooFilter<T> create(Funnel<? super T> funnel, int expectedInsertions) {
        return create(funnel, (long) expectedInsertions);
    }

    /**
     * Creates a {@link CuckooFilter CuckooFilter<T>} with the expected number of
     * insertions and a default expected false positive probability of 3.2%.
     * <p/>
     * <p>Note that overflowing a {@code CuckooFilter} with significantly more elements
     * than specified, will result in its saturation causing {@code put(t)} to reject new additions.
     * <p/>
     * <p>The constructed {@code CuckooFilter<T>} will be serializable if the provided
     * {@code Funnel<T>} is.
     * <p/>
     * <p>It is recommended that the funnel be implemented as a Java enum. This has the
     * benefit of ensuring proper serialization and deserialization, which is important
     * since {@link #equals} also relies on object identity of funnels.
     *
     * @param funnel             the funnel of T's that the constructed {@code CuckooFilter<T>} will use
     * @param expectedInsertions the number of expected insertions to the constructed
     *                           {@code CuckooFilter<T>}; must be positive
     * @return a {@code CuckooFilter}
     */
    @CheckReturnValue
    public static <T> CuckooFilter<T> create(Funnel<? super T> funnel, long expectedInsertions) {
        return create(funnel, expectedInsertions, 0.032D);
    }

  /*
   * Space optimization cheat sheet, per CuckooFilter § 5.1 :
   *
   * Given:
   *   n: expected insertions
   *   e: expected false positive probability (e.g. 0.03D for 3% fpp)
   *
   * Choose:
   *   b: bucket size in entries (2, 4, 8)
   *   a: load factor (proportional to b)
   *
   * Calculate:
   *   f: fingerprint size in bits
   *   m: table size in buckets
   *
   *
   * 1) Choose b =     8   | 4 |   2
   *      when e : 0.00001 < e ≤ 0.002
   *      ref: CuckooFilter § 5.1 ¶ 5, "Optimal bucket size"
   *
   * 2) Choose a =  50% | 84% | 95.5% | 98%
   *      when b =   1  |  2  |  4    |  8
   *      ref: CuckooFilter § 5.1 ¶ 2, "(1) Larger buckets improve table occupancy"
   *
   * 2) Optimal f = ceil( log2(2b/e) )
   *    ref: CuckooFilter § 5.1 Eq. (6), "f ≥ log2(2b/e) = [log2(1/e) + log2(2b)]"
   *
   * 3) Required m = evenCeil( ceiling( ceiling( n/a ) / b ) )
   *       Minimum entries (B) = n/a rounded up
   *       Minimum buckets (m) = B/b rounded up to an even number
   */

    /**
     * Selects the optimal number of entries per bucket, or bucket size, ({@code b}) given the
     * expected false positive probability ({@code e}).
     *
     * @param e the desired false positive probability (must be positive and less than 1.0)
     * @return optimal number of entries per bucket
     */
    @VisibleForTesting
    static int optimalEntriesPerBucket(double e) {
        checkArgument(e > 0.0D, "e must be > 0.0");
        // [TODO: ref Cuckoo section 5.1, "Optimal bucket size"]
        if (0.00001 > e) {
            return 8;
        } else if (0.002 >= e) {
            return 2;
        } else {
            return 4;
        }
    }

    /**
     * Selects the optimal load factor ({@code a}) given the number of entries per bucket
     * ({@code b}).
     *
     * @param b number of entries per bucket
     * @return load factor, positive and less than 1.0
     */
    @VisibleForTesting
    static double optimalLoadFactor(int b) {
        checkArgument(b ==2 || b == 4 || b == 8, "b must be 2, 4, or 8");
        if (b==2) {
            return 0.84D;
        } else if (b==4) {
            return 0.955D;
        } else {
            return 0.98D;
        }
    }

    /**
     * Calculates the optimal number of bits per entry ({@code f}) given the false positive
     * probability ({@code e}) and the number of entries per bucket ({@code b}).
     *
     * @param e the desired false positive probability (must be positive and less than 1.0)
     * @param b number of entries per bucket
     * @return number of bits per entry
     */
    @VisibleForTesting
    static int optimalBitsPerEntry(double e, int b) {
        checkArgument(e > 0.0D, "e must be > 0.0");
        return log2(2 * b / e, HALF_DOWN);
    }

    /**
     * Calculates the minimal required number of buckets given the expected insertions {@code n},
     *  and the number of entries per bucket ({@code b}).
     *
     * @param n the number of expected insertions
     * @param b number of entries per bucket
     * @return number of buckets
     */
    @VisibleForTesting
    static long optimalNumberOfBuckets(long n, int b) {
        checkArgument(n > 0, "n must be > 0");
        return evenCeil(divide((long) ceil(n / optimalLoadFactor(b)), b, CEILING));
    }

    static long evenCeil(long n) {
        return (n + 1) / 2 * 2;
    }

    private Object writeReplace() {
        return new SerialForm<T>(this);
    }

    private static class SerialForm<T> implements Serializable {
        final long[] data;
        final long numBuckets;
        final int numEntriesPerBucket;
        final int numBitsPerEntry;
        final Funnel<? super T> funnel;
        final Strategy strategy;

        SerialForm(CuckooFilter<T> filter) {
            this.data = filter.table.data;
            this.numBuckets = filter.numBuckets;
            this.numEntriesPerBucket = filter.numEntriesPerBucket;
            this.numBitsPerEntry = filter.numBitsPerEntry;
            this.funnel = filter.funnel;
            this.strategy = filter.strategy;
        }

        Object readResolve() {
            return new CuckooFilter<T>(new CuckooTable(data, 0L, numBuckets, numEntriesPerBucket, numBitsPerEntry), numBuckets, numEntriesPerBucket, numBitsPerEntry, funnel, strategy);
        }

        private static final long serialVersionUID = 1;
    }

    /**
     * Writes this {@code CuckooFilter} to an output stream, with a custom format (not Java
     * serialization). This has been measured to save at least 400 bytes compared to regular
     * serialization.
     * <p/>
     * <p>Use {@linkplain #readFrom(InputStream, Funnel)} to reconstruct the written CuckooFilter.
     */
    public void writeTo(OutputStream out) throws IOException {
        /*
         * Serial form:
         * 1 signed byte for the strategy
         * 1 big endian long for the number of buckets
         * 1 big endian int for the number of entries per bucket
         * 1 big endian int for the fingerprint size in bits
         * 1 big endian int, the number of longs in our table's data
         * N big endian longs of our table's data
         */
        DataOutputStream dout = new DataOutputStream(out);
        dout.writeByte(SignedBytes.checkedCast(strategy.ordinal()));
        dout.writeLong(numBuckets);
        dout.writeInt(numEntriesPerBucket);
        dout.writeInt(numBitsPerEntry);
        dout.writeInt(table.data.length);
        for (long value : table.data) {
            dout.writeLong(value);
        }
    }

    /**
     * Reads a byte stream, which was written by {@linkplain #writeTo(OutputStream)}, into
     * a {@code CuckooFilter<T>}.
     * <p/>
     * The {@code Funnel} to be used is not encoded in the stream, so it must be provided here.
     * <b>Warning:</b> the funnel provided <b>must</b> behave identically to the one used to
     * populate the original Cuckoo filter!
     *
     * @throws IOException if the InputStream throws an {@code IOException}, or if its data does
     *                     not appear to be a CuckooFilter serialized using the
     *                     {@linkplain #writeTo(OutputStream)} method.
     */
    @CheckReturnValue
    public static <T> CuckooFilter<T> readFrom(InputStream in, Funnel<T> funnel) throws IOException {
        checkNotNull(in, "InputStream");
        checkNotNull(funnel, "Funnel");
        int strategyOrdinal = -1;
        long numBuckets = -1L;
        int numEntriesPerBucket = -1;
        int numBitsPerEntry = -1;
        int dataLength = -1;
        try {
            DataInputStream din = new DataInputStream(in);
            // currently this assumes there is no negative ordinal; will have to be updated if we
            // add non-stateless strategies (for which we've reserved negative ordinals; see
            // Strategy.ordinal()).
            strategyOrdinal = din.readByte();
            numBuckets = din.readLong();
            numEntriesPerBucket = din.readInt();
            numBitsPerEntry = din.readInt();
            dataLength = din.readInt();

            Strategy strategy = CuckooFilterStrategies.values()[strategyOrdinal];
            long[] data = new long[dataLength];
            for (int i = 0; i < data.length; i++) {
                data[i] = din.readLong();
            }
            return new CuckooFilter<T>(new CuckooTable(data, 0L, numBuckets, numEntriesPerBucket, numBitsPerEntry), numBuckets, numEntriesPerBucket, numBitsPerEntry, funnel, strategy);
        } catch (RuntimeException e) {
            IOException ioException = new IOException(
                    "Unable to deserialize CuckooFilter from InputStream."
                            + " strategyOrdinal: " + strategyOrdinal
                            + " numBuckets: " + numBuckets
                            + " numEntriesPerBucket: " + numEntriesPerBucket
                            + " numBitsPerEntry: " + numBitsPerEntry
                            + " dataLength: " + dataLength);
            ioException.initCause(e);
            throw ioException;
        }
    }
}
